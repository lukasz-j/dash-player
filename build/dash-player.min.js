var Dash = {model: {}, mpd: {}, streaming: {}, log: {}, utils: {}, event: {}};
Dash.Player = function (a, b, c) {
    "use strict";
    var d, e, f, g, h = function (h) {
        var i, j;
        return b.MediaSource ? (i = new b.MediaSource, j = URL.createObjectURL(i), a.pause(), a.src = j, g = Dash.streaming.DefaultInitRepresentationPicker(), void i.addEventListener("sourceopen", function () {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "MediaSource successfully open"), d = Dash.streaming.PlaybackManager(h, i, c, e, f, g)
        }, !1)) : void c.dispatchLogEvent(Dash.log.LogLevel.ERROR, "MediaSource API is not supported by your browser, cannot continue")
    }, i = function (a, b, d) {
        var e = Dash.mpd.Parser(c).generateModel(a.responseText, d.url, d.isYouTube);
        "undefined" == typeof e ? c.dispatchLogEvent(Dash.log.LogLevel.ERROR, "Model generated from mpd file is empty, cannot continue") : (c.dispatchEvent({
            type: Dash.event.Events.MPD_LOADED,
            value: e
        }), h(e))
    };
    return {
        load: function (a, b) {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Trying to load MPD file from " + a + ". URL will be considered as " + (b ? "YouTube movie" : "mpd file")), Dash.mpd.Downloader(a, b, i, c).downloadMpdFile()
        }, changeRepresentationToLower: function (a, b) {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Received changing representation to lower request for " + a.name), d.changeRepresentationToLower(a, b)
        }, changeRepresentationToHigher: function (a, b) {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Received changing representation to higher request for " + a.name), d.changeRepresentationToHigher(a, b)
        }, changeRepresentation: function (a, b) {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Received changing representation to representation with id " + b + " for " + a.name), d.changeRepresentation(a, b)
        }, disableAdaptation: function () {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Received disabling adaptation request"), d.disableAdaptation()
        }, enableAdaptation: function (a) {
            c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Received enabling adaptation request, using " + a + " method"), d.enableAdaptation(a)
        }
    }
}, Dash.event.EventBus = function () {
    "use strict";
    var a = {}, b = function (b) {
        return a.hasOwnProperty(b) || (a[b] = []), a[b]
    };
    return {
        addEventListener: function (a, c) {
            var d = b(a);
            return -1 === d.indexOf(c) ? (d.push(c), !0) : !1
        }, removeEventListener: function (a, c) {
            var d = b(a), e = d.indexOf(c);
            return e > -1 ? (d.splice(e, 1), !0) : !1
        }, dispatchEvent: function (a) {
            for (var c = b(a.type), d = 0; d < c.length; d += 1)c[d].call(this, a)
        }, dispatchLogEvent: function (a, b) {
            this.dispatchEvent({type: Dash.event.Events.LOG_MESSAGE, value: {level: a, message: b}})
        }
    }
}, Dash.event.Events = {
    MPD_LOADED: "mpdLoaded",
    ADAPTATION_SET_INITIALIZED: "adaptationSetInitialized",
    REPRESENTATION_INITIALIZED: "representationInitialized",
    REPRESENTATION_CHANGED: "representationChanged",
    LOG_MESSAGE: "logMessage",
    SEGMENT_DOWNLOADED: "segmentDownloaded"
}, Dash.log.ConsoleLogger = function (a) {
    "use strict";
    var b = function (b, c) {
        switch (b) {
            case Dash.log.LogLevel.DEBUG:
                a.debug(c);
                break;
            case Dash.log.LogLevel.INFO:
                a.info(c);
                break;
            case Dash.log.LogLevel.WARN:
                a.warn(c);
                break;
            case Dash.log.LogLevel.ERROR:
                a.error(c)
        }
    };
    return {
        onMessageReceived: function (a) {
            b(a.value.level, a.value.message)
        }, logMessage: function (a, c) {
            b(a, c)
        }
    }
}, Dash.log.LogLevel = {DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3}, Dash.model.AdaptationSet = function (a, b) {
    "use strict";
    var c, d, e, f, g = Dash.utils.ParserModelUtils.getBaseURLFromNode(a), h = a.getAttribute("codecs"), i = Dash.utils.ParserModelUtils.getDigitAttribute(a, "width"), j = Dash.utils.ParserModelUtils.getDigitAttribute(a, "height"), k = Dash.utils.ParserModelUtils.getDigitAttribute(a, "frameRate"), l = Dash.utils.ParserModelUtils.getDigitAttribute(a, "audioSamplingRate"), m = function (b) {
        d = a.hasAttribute("mimeType") ? a.getAttribute("mimeType") : b[0].getMimeType(), e = Dash.model.MediaFormat.createMediaFormatFromMimeType(d), f = Dash.model.MediaType.createMediaTypeFromMimeType(d)
    };
    return {
        name: "AdaptationSet", setRepresentations: function (a) {
            c = a, m(c)
        }, getRepresentations: function () {
            return c
        }, getParent: function () {
            return b
        }, getBaseURL: function () {
            return g
        }, getIndexOfRepresentation: function (a) {
            for (var b = 0; b < c.length; b += 1)if (c[b].equals(a))return b
        }, getLowestRepresentation: function () {
            return c[0]
        }, getHighestRepresentation: function () {
            return c[c.length - 1]
        }, getRepresentationByWidth: function (a) {
            for (var b = 0; b < c.length; b += 1) {
                var d = c[b];
                if (d.getWidth() === a)return d
            }
        }, getRepresentationShortForms: function () {
            return c.map(function (a) {
                return a.toShortForm()
            })
        }, getMimeType: function () {
            return d
        }, getFormat: function () {
            return e
        }, getCodecs: function () {
            return h
        }, getWidth: function () {
            return i
        }, getHeight: function () {
            return j
        }, getFrameRate: function () {
            return k
        }, getAudioSamplingRate: function () {
            return l
        }, getMediaType: function () {
            return f
        }, isVideo: function () {
            return f === Dash.model.MediaType.VIDEO
        }, isAudio: function () {
            return f === Dash.model.MediaType.AUDIO
        }, isText: function () {
            return f === Dash.model.MediaType.TEXT
        }
    }
}, Dash.model.MPD = function (a, b) {
    "use strict";
    var c, d = function (a, b) {
        if ("undefined" == typeof a || "./" === a.innerHTML) {
            var c = b.lastIndexOf("/");
            return b.substr(0, c)
        }
        return Dash.utils.ParserModelUtils.replaceAmpersandsInURL(a.innerHTML)
    }, e = function (a) {
        return [Dash.model.MPDProfile.createMPDProfileFromString(a)]
    }, f = a.getAttribute("profiles"), g = a.getAttribute("type"), h = a.getAttribute("mediaPresentationDuration"), i = a.getAttribute("minBufferTime"), j = Dash.utils.ParserModelUtils.findDirectChildByTagName(a, "BaseURL"), k = d(j, b), l = Dash.model.MPDType.createMPDTypeFromString(g), m = Dash.utils.ParserModelUtils.convertXMLDurationFormat(h), n = Dash.utils.ParserModelUtils.convertXMLDurationFormat(i), o = e(f);
    return {
        name: "MPD", setPeriod: function (a) {
            c = a
        }, getPeriod: function () {
            return c
        }, getProfiles: function () {
            return o
        }, getProfilesAsString: function () {
            return o.map(function (a) {
                return a.name + " "
            })
        }, getType: function () {
            return l
        }, getBaseURL: function () {
            return k
        }, getMediaPresentationDuration: function () {
            return m
        }, getMediaPresentationDurationFormatted: function () {
            return Dash.utils.CommonUtils.convertDurationInSecondsToPrettyString(m)
        }, getMinBufferTime: function () {
            return n
        }, getMinBufferTimeFormatted: function () {
            return Dash.utils.CommonUtils.convertDurationInSecondsToPrettyString(n)
        }
    }
}, Dash.model.Period = function (a, b) {
    "use strict";
    var c, d = function (a) {
        return a.isAudio()
    }, e = function (a) {
        return a.isVideo()
    }, f = function (a) {
        return a.isText()
    }, g = function (a) {
        for (var b = [], d = 0; d < c.length; d += 1)a(c[d]) && b.push(c[d]);
        return b
    }, h = Dash.utils.ParserModelUtils.getBaseURLFromNode(a);
    return {
        name: "Period", setAdaptationSets: function (a) {
            c = a
        }, getAdaptationSets: function () {
            return c
        }, getParent: function () {
            return b
        }, getBaseURL: function () {
            return h
        }, getAdaptationSet: function (a, b) {
            if (a === Dash.model.MediaType.VIDEO)return this.getVideoAdaptationSet(b);
            if (a === Dash.model.MediaType.AUDIO)return this.getAudioAdaptationSet(b);
            throw new Error("Unsupported adaptation set format - " + a)
        }, getAudioAdaptationSets: function () {
            return g(d)
        }, getVideoAdaptationSets: function () {
            return g(e)
        }, getTextAdaptationSets: function () {
            return g(f)
        }, getAudioAdaptationSet: function (a) {
            for (var b = 0; b < c.length; b += 1)if (c[b].isAudio() && c[b].getFormat() === a)return c[b]
        }, getVideoAdaptationSet: function (a) {
            for (var b = 0; b < c.length; b += 1)if (c[b].isVideo() && c[b].getFormat() === a)return c[b]
        }
    }
}, Dash.model.Representation = function (a, b) {
    "use strict";
    var c, d = Dash.utils.ParserModelUtils.getBaseURLFromNode(a), e = a.getAttribute("id"), f = a.getAttribute("codecs"), g = Dash.utils.ParserModelUtils.getDigitAttribute(a, "bandwidth"), h = Dash.utils.ParserModelUtils.getDigitAttribute(a, "width"), i = Dash.utils.ParserModelUtils.getDigitAttribute(a, "height"), j = Dash.utils.ParserModelUtils.getDigitAttribute(a, "frameRate"), k = Dash.utils.ParserModelUtils.getDigitAttribute(a, "audioSamplingRate"), l = a.getAttribute("mimeType");
    return {
        name: "Representation", orderNumber: 0, setSegment: function (a) {
            c = a
        }, getSegment: function () {
            return c
        }, getParent: function () {
            return b
        }, getBaseURL: function () {
            return d
        }, getAdaptationSet: function () {
            return b
        }, getMimeType: function () {
            return l || b.getMimeType()
        }, getId: function () {
            return e
        }, getBandwidth: function () {
            return g
        }, getWidth: function () {
            return h ? h : b.getWidth()
        }, getHeight: function () {
            return i ? i : b.getHeight()
        }, getFrameRate: function () {
            return j ? j : b.getFrameRate()
        }, getCodecs: function () {
            return f ? f : b.getCodecs()
        }, getAudioSamplingRate: function () {
            return k ? k : b.getAudioSamplingRate()
        }, toShortForm: function () {
            return i ? j ? i + " @ " + j + "fps" : String(i) : k ? (k / 1e3).toFixed(1) + "kHz @ " + (g / 1e3).toFixed(2) + "kbps" : g / 1e3 + "kbps"
        }, equals: function (a) {
            return e === a.getId()
        }
    }
}, Dash.model.MPDProfile = {
    FULL: {value: 0, name: "full", urn: "urn:mpeg:dash:profile:full:2011"},
    ONDEMAND: {value: 1, name: "on-demand", urn: "urn:mpeg:dash:profile:isoff-on-demand:2011"},
    LIVE: {value: 2, name: "dynamic", urn: "urn:mpeg:dash:profile:isoff-live:2011"},
    MAIN: {value: 3, name: "main", urn: "urn:mpeg:dash:profile:isoff-main:2011"},
    createMPDProfileFromString: function (a) {
        "use strict";
        var b;
        for (b in this)if (this.hasOwnProperty(b) && "function" != typeof b && this[b].urn === a)return this[b];
        throw new Error("Illegal MPD profile urn - " + a)
    }
}, Dash.model.MPDType = {
    STATIC: {value: 1, name: "static"},
    DYNAMIC: {value: 2, name: "dynamic"},
    createMPDTypeFromString: function (a) {
        "use strict";
        var b;
        if (!a)return this.STATIC;
        for (b in this)if (this.hasOwnProperty(b) && "function" != typeof b && this[b].name === a)return this[b];
        throw new Error("Illegal MPD type - " + a)
    }
}, Dash.model.MediaFormat = {
    MP4: {value: 1, name: "mp4"},
    WEBM: {value: 2, name: "webm"},
    VTT: {value: 3, name: "vtt"},
    createMediaFormatFromMimeType: function (a) {
        "use strict";
        var b, c = a.split("/")[1];
        for (b in this)if (this.hasOwnProperty(b) && "function" != typeof b && this[b].name === c)return this[b];
        throw new Error("Unsupported media format - " + c)
    }
}, Dash.model.MediaType = {
    VIDEO: {value: 1, name: "video"},
    AUDIO: {value: 2, name: "audio"},
    TEXT: {value: 3, name: "text"},
    createMediaTypeFromMimeType: function (a) {
        "use strict";
        var b, c = a.split("/")[0];
        for (b in this)if (this.hasOwnProperty(b) && "function" != typeof b && this[b].name === c)return this[b];
        throw new Error("Unsupported media type - " + c)
    }
}, Dash.model.ListSegment = function (a, b) {
    "use strict";
    var c = function (a, b) {
        var c = b.getElementsByTagName("Initialization")[0], d = c.getAttribute("sourceURL");
        return Dash.utils.ParserModelUtils.resolveAttributeURL(a, d)
    }, d = function (a, b) {
        for (var c, d = b.getElementsByTagName("SegmentURL"), e = [], f = 0; f < d.length; f += 1)c = d[f].getAttribute("media"), e.push(Dash.utils.ParserModelUtils.resolveAttributeURL(a, c));
        return e
    }, e = Dash.utils.ParserModelUtils.findBaseURLInModel(b), f = c(e, a), g = d(e, a);
    return {
        name: "ListSegment", getParent: function () {
            return b
        }, getInitializationURL: function () {
            return f
        }, getSegmentURLs: function () {
            return g
        }
    }
}, Dash.model.RangeSegment = function (a, b, c) {
    "use strict";
    var d, e = a.getElementsByTagName("Initialization")[0].getAttribute("range"), f = a.getAttribute("indexRange"), g = b.getBaseURL(), h = e.split("-"), i = f.split("-"), j = parseInt(h[0], 10), k = parseInt(h[1], 10), l = parseInt(i[0], 10), m = parseInt(i[1], 10), n = function (a) {
        return a.begin + "-" + a.end
    }, o = function () {
        return {begin: j, end: m}
    }, p = function (a) {
        var b, c = [], d = a.subarray(l, m + 1), e = [], f = m + 1;
        for (b = 32; b < d.length; b += 12)c.push(16777216 * d[b] + 65536 * d[b + 1] + 256 * d[b + 2] + d[b + 3] - 1);
        for (b = 0; b < c.length; b += 1)e.push({begin: f, end: f + c[b]}), f += c[b] + 1;
        return e
    };
    if (!Dash.utils.ParserModelUtils.isURLAbsolute(g)) {
        var q = Dash.utils.ParserModelUtils.findBaseURLInModel(b.getParent().getParent());
        g = Dash.utils.ParserModelUtils.resolveAttributeURL(q, g)
    }
    return {
        name: "RangeSegment", getRepresentation: function () {
            return b
        }, computeSegmentRanges: function (a) {
            d = p(a)
        }, getInitializationURL: function () {
            var a = o();
            return c ? Dash.utils.ParserModelUtils.createURLWithRange(g, a.begin, a.end) : {url: g, range: n(a)}
        }, getSegmentURLs: function () {
            var a, b = [];
            if (!d)return [];
            if (c)for (a = 0; a < d.length; a += 1)b.push(Dash.utils.ParserModelUtils.createURLWithRange(g, d[a].begin, d[a].end)); else for (a = 0; a < d.length; a += 1)b.push({
                url: g,
                range: n(d[a])
            });
            return b
        }, getHeaderStartIndex: function () {
            return j
        }, getHeaderEndIndex: function () {
            return m
        }, getInitializationStartIndex: function () {
            return j
        }, getInitializationEndIndex: function () {
            return k
        }, getSegmentBaseStartIndex: function () {
            return l
        }, getSegmentBaseEndIndex: function () {
            return m
        }
    }
}, Dash.model.TemplateSegment = function (a, b) {
    "use strict";
    var c, d, e = {
        doubleDollar: "$$",
        representation: "$RepresentationID$",
        bandwidth: "$Bandwidth",
        number: "$Number$",
        time: "$Time$"
    }, f = function (a, b, c) {
        var d = b / c;
        return Math.ceil(a / d)
    }, g = function (a, b, c) {
        var d = Dash.utils.CommonUtils.replaceAll(a, e.doubleDollar, ""), f = Dash.utils.CommonUtils.replaceAll(d, e.representation, b), g = Dash.utils.CommonUtils.replaceAll(f, e.bandwidth, c);
        return g
    }, h = function (a, c, d, f) {
        for (var h = [], i = 0; f > i; i += 1) {
            var j = i * d, k = g(a, b.getId(), b.getBandwidth()), l = Dash.utils.CommonUtils.replaceAll(k, e.time, j);
            h.push(Dash.utils.ParserModelUtils.resolveAttributeURL(c, l))
        }
        return h
    }, i = function (a, c, d, f) {
        for (var h = [], i = 0; f > i; i += 1) {
            var j = i + d, k = g(a, b.getId(), b.getBandwidth()), l = Dash.utils.CommonUtils.replaceAll(k, e.number, j);
            h.push(Dash.utils.ParserModelUtils.resolveAttributeURL(c, l))
        }
        return h
    }, j = function (a) {
        return a.getParent().getParent().getParent().getMediaPresentationDuration()
    }, k = Dash.utils.ParserModelUtils.findBaseURLInModel(b), l = a.getAttribute("media"), m = parseInt(a.getAttribute("timescale"), 10), n = a.getAttribute("initialization"), o = Dash.utils.ParserModelUtils.resolveAttributeURL(k, n), p = j(b), q = [];
    if (l.indexOf(e.time) > -1) {
        var r = a.getElementsByTagName("S")[0];
        c = parseInt(r.getAttribute("d"), 10), d = f(p, c, m), q = h(l, k, c, d)
    } else {
        if (!(l.indexOf(e.number) > -1))throw new Error("Error template url format " + l);
        var s = parseInt(a.getElementsByTagName("startNumber")[0], 10) || 1;
        c = parseInt(a.getAttribute("duration"), 10), d = f(p, c, m), q = i(l, k, s, d)
    }
    return {
        name: "TemplateSegment", getRepresentation: function () {
            return b
        }, getTemplateURL: function () {
            return l
        }, getInitializationURL: function () {
            return o
        }, getSegmentURLs: function () {
            return q
        }
    }
}, Dash.mpd.Downloader = function (a, b, c, d) {
    "use strict";
    var e = "http://www.youtube.com", f = "/get_video_info?html5=1&video_id=", g = "v=", h = "dashmpd=", i = Dash.utils.AsyncDownloader(), j = function () {
        i.download(a, c)
    }, k = function (b) {
        for (var c = b.split("&"), e = 0; e < c.length; e += 1)if (0 === c[e].indexOf(h)) {
            var f = decodeURIComponent(c[e].substring(h.length));
            return d.dispatchLogEvent(Dash.log.LogLevel.INFO, "MPD url find in response from YouTube, " + f), f
        }
        d.dispatchLogEvent(Dash.log.LogLevel.ERROR, "Cannot find mpd file localization for " + a + ". Server respond with: " + decodeURIComponent(b))
    }, l = function () {
        var b = n(a), c = e + f + b;
        i.download(c, m)
    }, m = function (a) {
        var b = k(a.responseText);
        b && i.download(b, function (a, b, d) {
            d.isYouTube = !0, c(a, b, d)
        })
    }, n = function (a) {
        for (var b = a.split("?"), c = 0; c < b.length; c += 1)if (0 === b[c].indexOf(g))return b[c].substring(g.length)
    };
    return {
        downloadMpdFile: function () {
            b ? l() : j()
        }
    }
}, Dash.mpd.Parser = function (a) {
    "use strict";
    var b = function (b, c) {
        var d = Dash.model.MPD(b, c), e = "Mpd element created from xml node, type: " + d.getType().name + ", profiles: " + d.getProfilesAsString() + ", duration: " + d.getMediaPresentationDurationFormatted();
        return a.dispatchLogEvent(Dash.log.LogLevel.DEBUG, e), d
    }, c = function (b, c) {
        var d = Dash.model.Period(b, c);
        return a.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Period element created from xml node"), d
    }, d = function (b, c) {
        var d = Dash.model.AdaptationSet(b, c);
        return a.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Adaptation set element created from xml node"), d
    }, e = function (b, c) {
        var d = Dash.model.Representation(b, c), e = "Representation element created from xml node, id: " + d.getId() + ", bandwidth: " + d.getBandwidth();
        return a.dispatchLogEvent(Dash.log.LogLevel.DEBUG, e), d
    }, f = function (b, c, d) {
        var e, f, g = c.getBaseURL(), h = b.getElementsByTagName("SegmentTemplate")[0], i = b.getElementsByTagName("SegmentBase")[0], j = b.getElementsByTagName("SegmentList")[0];
        if (g && i && !h && !j)e = Dash.model.RangeSegment(i, c, d), f = "Range segment element created from xml node, baseURL: " + c.getBaseURL(); else if (j)e = Dash.model.ListSegment(j, c), f = "List segment element created from xml node, initialization url: " + e.getInitializationURL(); else {
            if (!h) {
                if (g)return;
                throw new Error("Unsupported segment representation")
            }
            e = Dash.model.TemplateSegment(h, c), f = "Template segment element created from xml node, template url: " + e.getTemplateURL()
        }
        return a.dispatchLogEvent(Dash.log.LogLevel.DEBUG, f), e
    };
    return {
        generateModel: function (g, h, i) {
            a.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Parsing downloaded mpd file using DOMParser");
            var j = (new DOMParser).parseFromString(g, "text/xml"), k = j.getElementsByTagName("MPD")[0], l = b(k, h), m = k.getElementsByTagName("Period")[0], n = c(m, l);
            l.setPeriod(n);
            for (var o = m.getElementsByTagName("AdaptationSet"), p = [], q = 0; q < o.length; ++q) {
                var r = o[q], s = d(r, n);
                p.push(s);
                for (var t = r.getElementsByTagName("Representation"), u = [], v = 0; v < t.length; v += 1) {
                    var w = t[v], x = e(w, s), y = f(w, x, i);
                    x.setSegment(y), u.push(x)
                }
                u.sort(function (a, b) {
                    return a.getBandwidth() - b.getBandwidth()
                }), u.forEach(function (a, b) {
                    a.orderNumber = b + 1
                }), s.setRepresentations(u)
            }
            return n.setAdaptationSets(p), a.dispatchLogEvent(Dash.log.LogLevel.INFO, "MPD file parsing finished and MPD model successfully created"), l
        }
    }
}, Dash.streaming.BufferManager = function (a) {
    "use strict";
    var b = [], c = function () {
        if (a.updating)setTimeout(c, 200); else {
            var d = b.pop();
            a.appendBuffer(d)
        }
    };
    return {
        appendBuffer: function (a) {
            b.push(a), c()
        }
    }
}, Dash.streaming.DefaultInitRepresentationPicker = function () {
    "use strict";
    var a = function (a) {
        var b, c = a.slice(0);
        c.sort(function (a, b) {
            return a.getHeight() - b.getHeight()
        }), b = c[0];
        for (var d = 1; d < c.length; d += 1) {
            if (c[d].getHeight() > 480)return b;
            b = c[d]
        }
        return b
    }, b = function (a) {
        var b = Math.floor(a.length / 2);
        return a[b]
    }, c = function (a) {
        return a[0]
    };
    return {
        chooseInitRepresentation: function (d, e) {
            switch (e) {
                case Dash.model.MediaType.VIDEO:
                    return a(d);
                case Dash.model.MediaType.AUDIO:
                    return b(d);
                case Dash.model.MediaType.TEXT:
                    return c(d)
            }
        }
    }
}, Dash.streaming.PlaybackManager = function (a, b, c, d, e, f) {
    "use strict";
    var g, h, i, j = [], k = 0, l = function (a) {
        var b = "Adaptation set has been chosen for " + a.getMediaType().name + ", mime type: " + a.getMimeType() + " representations count: " + a.getRepresentations().length;
        c.dispatchEvent({
            type: Dash.event.Events.ADAPTATION_SET_INITIALIZED,
            value: a
        }), c.dispatchLogEvent(Dash.log.LogLevel.INFO, b)
    }, m = function (a) {
        var b = "Init representation has been chosen for " + a.getAdaptationSet().getMediaType().name + ", number: " + a.orderNumber + ", id: " + a.getId() + ", bandwidth: " + a.getBandwidth();
        c.dispatchEvent({
            type: Dash.event.Events.REPRESENTATION_INITIALIZED,
            value: a
        }), c.dispatchLogEvent(Dash.log.LogLevel.INFO, b)
    }, n = function () {
        if (j.length > 0)for (var a = j.length - 1; a >= 0;)j[a].isStreamingFinished() ? (c.dispatchLogEvent(Dash.log.LogLevel.INFO, "Streaming for " + j[a].getMediaType().name + " has finished"), j = j.slice(0, a)) : j[a].appendNextSegment(), a -= 1
    }, o = function () {
        c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Streaming initialization has finished. All initialization headers for representations have been downloaded"), k = 0, n()
    }, p = function () {
        k += 1, k === j.length && o()
    }, q = function () {
        k = 0, n()
    }, r = function () {
        k += 1, k === j.length && q()
    }, s = function (a, b) {
        var c = null;
        if (e)c = e.chooseAdaptationSet(a.getAdaptationSets(), Dash.model.MediaType.VIDEO); else if (b === Dash.model.MediaType.VIDEO)c = a.getVideoAdaptationSet(Dash.model.MediaFormat.MP4); else {
            if (b !== Dash.model.MediaType.AUDIO) {
                if (b === Dash.model.MediaType.TEXT)return;
                throw new Error("Not supported media type")
            }
            c = a.getAudioAdaptationSet(Dash.model.MediaFormat.MP4)
        }
        return l(c), c
    }, t = function (a) {
        return s(a, Dash.model.MediaType.VIDEO)
    }, u = function (a) {
        return s(a, Dash.model.MediaType.AUDIO)
    }, v = function (a) {
        return s(a, Dash.model.MediaType.TEXT)
    }, w = function (a, b) {
        var d;
        return f ? (c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Using InitRepresentation for choosing init representation for " + b.name), d = f.chooseInitRepresentation(a.getRepresentations(), b)) : (c.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "InitRepresentaionPicker is not defined, representation with lowest bandwidth will be chosen for " + b.name), d = a.getRepresentations()[0]), m(d), d
    }, x = function (a, d) {
        var e = Dash.utils.CommonUtils.createSourceBufferInitString(a, d);
        return c.dispatchLogEvent(Dash.log.LogLevel.INFO, 'Creating source buffer object using init string "' + e + '"'), b.addSourceBuffer(e)
    }, y = function (a, b) {
        c.dispatchEvent(Dash.log.LogLevel.DEBUG, "Creating streaming manager for " + b.name);
        var d = w(a, b), e = x(a, d);
        return Dash.streaming.StreamingManager(a, d, e, p, r, c)
    }, z = function () {
        var b = a.getPeriod(), c = t(b), d = u(b), e = v(b);
        c && (g = y(c, Dash.model.MediaType.VIDEO), j.push(g)), d && (h = y(d, Dash.model.MediaType.AUDIO), j.push(h)), e && (i = y(e, Dash.model.MediaType.TEXT), j.push(i));
        for (var f = 0; f < j.length; f += 1)j[f].appendInitialization()
    };
    return z(), {
        changeRepresentationToHigher: function (a, b) {
            a === Dash.model.MediaType.AUDIO && h ? h.changeRepresentationToHigher(b) : a === Dash.model.MediaType.VIDEO && g ? g.changeRepresentationToHigher(b) : a === Dash.model.MediaType.TEXT && i ? i.changeRepresentationToHigher(b) : c.dispatchLogEvent(Dash.log.LogLevel.WARN, "Unsupported media type found while changing representation to higher " + a)
        }, changeRepresentationToLower: function (a, b) {
            a === Dash.model.MediaType.AUDIO && h ? h.changeRepresentationToLower(b) : a === Dash.model.MediaType.VIDEO && g ? g.changeRepresentationToLower(b) : a === Dash.model.MediaType.TEXT && i ? i.changeRepresentationToLower(b) : c.dispatchLogEvent(Dash.log.LogLevel.WARN, "Unsupported media type found while changing representation to lower " + a)
        }, changeRepresentation: function (a, b) {
            a === Dash.model.MediaType.AUDIO && h ? h.changeRepresentation(b) : a === Dash.model.MediaType.VIDEO && g ? g.changeRepresentation(b) : a === Dash.model.MediaType.TEXT && i ? i.changeRepresentation(b) : c.dispatchLogEvent(Dash.log.LogLevel.WARN, "Unsupported media type found while changing representation " + a)
        }, disableAdaptation: function () {
            c.dispatchEvent(Dash.log.LogLevel.INFO, "Adaptation has been disabled by user"), d = void 0
        }, enableAdaptation: function (a) {
            c.dispatchEvent(Dash.log.LogLevel.INFO, "Adaptation has been enabled using algorithm " + a), c.dispatchLogEvent(Dash.log.LogLevel.WARN, "Dynamic adaptation is not supported for now"), d = null
        }
    }
}, Dash.streaming.RepresentationManager = function (a, b, c) {
    "use strict";
    var d = a.getRepresentations(), e = c(d);
    return b.fireRepresentationChangedEvent(d[e]), {
        getCurrentRepresentation: function () {
            return d[e]
        }, isPresentRepresentationHighest: function () {
            return e === d.length - 1
        }, switchRepresentationToHigher: function (a) {
            a = a || 1, e + a >= d.length ? e = d.length - 1 : e += a;
            var c = d[e];
            return b.fireRepresentationChangedEvent(c), c
        }, isPresentRepresentationLowest: function () {
            return 0 === e
        }, switchRepresentationToLower: function (a) {
            a = a || 1, 0 > e - a ? e = 0 : e -= a;
            var c = d[e];
            return b.fireRepresentationChangedEvent(c), c
        }
    }
}, Dash.streaming.RepresentationRepository = function () {
    "use strict";
    var a = {}, b = function (b) {
        if (void 0 === a[b])throw new Error("Representation buffer not initialized for representation - " + b)
    };
    return {
        addRepresentation: function (b, c, d) {
            var e = b.getId();
            a[e] = {header: c, buffer: [], url: d}
        }, appendBuffer: function (c, d, e) {
            var f = c.getId();
            b(f), void 0 === a[f].buffer[d] && (a[f].buffer[d] = e)
        }, isBufferAlreadyDownloaded: function (c, d) {
            var e = c.getId();
            return b(e), void 0 !== a[e].buffer[d]
        }, getHeader: function (c) {
            var d = c.getId();
            return b(d), a[d].header
        }, getHeaderUrl: function (c) {
            var d = c.getId();
            return b(d), a[d].url
        }, getBuffer: function (c, d) {
            var e = c.getId();
            return b(e), a[e].buffer[d]
        }, getRepository: function () {
            return a
        }
    }
}, Dash.streaming.StreamingManager = function (a, b, c, d, e, f) {
    "use strict";
    var g, h, i = Dash.streaming.BufferManager(c), j = Dash.streaming.RepresentationRepository(), k = Dash.utils.AsyncDownloader(), l = b, m = a.getIndexOfRepresentation(b), n = a.getRepresentations(), o = 0, p = n.length - 1, q = 0, r = !1, s = {
        available: !1,
        index: 0
    }, t = function (a, b, c, d) {
        "string" == typeof a ? k.downloadBinaryFile(a, b, c, d) : k.downloadBinaryFilePart(a.url, b, d, d, a.range)
    }, u = function (b) {
        var c = "Representation changed for " + a.getMediaType().name + ", number: " + b.orderNumber + ", id: " + b.getId() + ", bandwidth: " + b.getBandwidth();
        f.dispatchEvent({
            type: Dash.event.Events.REPRESENTATION_CHANGED,
            value: l
        }), f.dispatchLogEvent(Dash.log.LogLevel.INFO, c)
    }, v = function (a) {
        m = a, l = n[m], g = j.getHeader(l), h = l.getSegment().getSegmentURLs(), u(l), i.appendBuffer(g)
    }, w = function (b) {
        var c = "Segment " + q + "/" + h.length + " downloaded for " + a.getMediaType().name + " url: " + b.url;
        f.dispatchEvent({
            type: Dash.event.Events.SEGMENT_DOWNLOADED,
            value: {mediaType: a.getMediaType(), currentSegment: q, maxSegment: h.length}
        }), f.dispatchLogEvent(Dash.log.LogLevel.DEBUG, c)
    }, x = function (a, b, c) {
        w(c);
        var d = new Uint8Array(a.response);
        i.appendBuffer(d), j.appendBuffer(l, q, d), s.available && s.index !== m && (v(s.index), s.available = !1), e.call(this, a, b, c)
    }, y = function (a) {
        for (var b = 0; b < n.length; b += 1)if (n[b].getId() === a)return b;
        return -1
    }, z = function (a) {
        var b = m + a;
        o > b ? b = 0 : b > p && (b = p), s.available = !0, s.index = b
    }, A = function (a) {
        var b = y(a);
        -1 === b ? f.logMessage(Dash.log.LogLevel.ERROR, "Cannot changed representation. Representations with index " + a + " not found") : (s.available = !0, s.index = b)
    }, B = function () {
        var b, c, d = -1, e = function () {
            return d += 1, d < n.length ? (b = n[d], c = b.getSegment().getInitializationURL(), !0) : !1
        }, g = function (d, h, i) {
            var k = "Initialization header successfully downloaded for " + a.getMediaType().name + " representation, number: " + b.orderNumber + ", id: " + b.getId() + ", bandwidth: " + b.getBandwidth() + ", url: " + i.url;
            f.dispatchLogEvent(Dash.log.LogLevel.INFO, k);
            var l = new Uint8Array(d.response);
            j.addRepresentation(b, l, i.url);
            var m = b.getSegment();
            "RangeSegment" === m.name && m.computeSegmentRanges(l), e() ? t(c, g) : r = !0
        };
        f.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Starting downloading headers for all available representations for " + a.getMediaType().name), e(), t(c, g)
    };
    return B(), {
        getMediaType: function () {
            return a.getMediaType()
        }, appendInitialization: function () {
            var b = this;
            r ? (f.dispatchLogEvent(Dash.log.LogLevel.DEBUG, "Appending initialization header to source buffer for " + a.getMediaType().name), g = j.getHeader(l), h = l.getSegment().getSegmentURLs(), i.appendBuffer(g), d.call(this)) : setTimeout(function () {
                b.appendInitialization()
            }, 500)
        }, appendNextSegment: function () {
            if (this.isStreamingFinished())f.logMessage(Dash.log.LogLevel.ERROR, "Cannot append next segment to buffer because its already finished for " + a.getMediaType()); else {
                var b = h[q];
                t(b, x), q += 1
            }
        }, isStreamingFinished: function () {
            return q === h.length
        }, changeRepresentationToHigher: function (a) {
            (!a || 0 > a) && (a = 1), z(a)
        }, changeRepresentation: function (a) {
            A(a)
        }, changeRepresentationToLower: function (a) {
            (!a || 0 > a) && (a = 1), z(-a)
        }
    }
}, Dash.utils.AsyncDownloader = function () {
    "use strict";
    var a = function (a, b, c, d, e, f, g) {
        var h, i, j = new XMLHttpRequest;
        b = b || 200, f && (j.responseType = f), e && (j.onprogress = e), j.onload = function (e) {
            j.status === b ? (i = new Date - h, c(j, e.loaded, {url: a, duration: i})) : d(j)
        }, h = new Date, j.open("GET", a, !0), g && j.setRequestHeader("Range", "bytes=" + g), j.send()
    };
    return {
        downloadBinaryFilePart: function (b, c, d, e, f) {
            a(b, 206, c, d, e, "arraybuffer", f)
        }, downloadBinaryFile: function (b, c, d, e) {
            a(b, 200, c, d, e, "arraybuffer")
        }, download: function (b, c, d, e) {
            a(b, 200, c, d, e)
        }
    }
}, Dash.utils.CommonUtils = {
    computeDownloadSpeed: function (a, b) {
        "use strict";
        return 8 * a / (b / 1e3)
    }, createSourceBufferInitString: function (a, b) {
        "use strict";
        var c;
        return c = a.getCodecs() ? a.getCodecs() : b.getCodecs(), a.getMimeType() + '; codecs="' + c + '"'
    }, escapeRegExp: function (a) {
        "use strict";
        return a.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1")
    }, replaceAll: function (a, b, c) {
        "use strict";
        return a.replace(new RegExp(this.escapeRegExp(b), "g"), c)
    }, convertDurationInSecondsToPrettyString: function (a) {
        "use strict";
        var b = Math.floor(a / 3600), c = Math.floor(a / 60), d = Math.floor(a % 60), e = Math.floor(a % 1 * 100), f = "", g = function (a, b) {
            return 10 > a && !b ? "0" + a : a.toString()
        };
        return 0 !== b && (f += g(b, !0) + ":"), 0 !== c && (f += g(c, 0 === f.length) + ":"), f += g(d, 0 === f.length), 0 !== e && (f += "." + e), f
    }
}, Dash.utils.ParserModelUtils = {
    isURLAbsolute: function (a) {
        "use strict";
        return 0 === a.indexOf("http://") || 0 === a.indexOf("https://")
    }, convertXMLDurationFormat: function (a) {
        "use strict";
        var b = function (a, b) {
            if ("undefined" == typeof a)return 0;
            var c = parseFloat(a.substr(0, a.length - 1));
            return 1 === b ? 3600 * c : 2 === b ? 60 * c : c
        }, c = 0, d = 0, e = /PT(\d+H)?(\d+M)?(\d+(\.\d+)?S)/i, f = e.exec(a);
        if (null === f)throw new Error("Wrong format for xml duration - " + a);
        for (d = 1; 3 >= d; d += 1)c += b(f[d], d);
        return c
    }, replaceAmpersandsInURL: function (a) {
        "use strict";
        return a.replace(/&amp;/g, "&")
    }, getBaseURLFromNode: function (a) {
        "use strict";
        var b = this.findDirectChildByTagName(a, "BaseURL");
        return "undefined" != typeof b ? this.replaceAmpersandsInURL(b.innerHTML) : void 0
    }, findBaseURLInModel: function (a) {
        "use strict";
        for (var b, c = a; c;) {
            if ("function" == typeof c.getBaseURL && (b = c.getBaseURL(), "undefined" != typeof b))return b;
            c = c.getParent()
        }
    }, resolveAttributeURL: function (a, b) {
        "use strict";
        var c = decodeURIComponent(b);
        return this.isURLAbsolute(c) ? c : a + "/" + c
    }, findDirectChildrenByTagName: function (a, b) {
        "use strict";
        for (var c = a.children, d = [], e = 0; e < c.length; e += 1)c[e].tagName === b && d.push(c[e]);
        return d
    }, findDirectChildByTagName: function (a, b) {
        "use strict";
        return this.findDirectChildrenByTagName(a, b)[0]
    }, getDigitAttribute: function (a, b) {
        "use strict";
        var c = a.getAttribute(b);
        return "undefined" != typeof c ? parseInt(c, 10) : void 0
    }, createURLWithRange: function (a, b, c) {
        "use strict";
        return a + "&range=" + b + "-" + c
    }
};